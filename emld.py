# a constructor for class Emld

from collections import OrderedDict # https://realpython.com/python-ordereddict/#:~:text=Python's%20OrderedDict%20is%20a%20dict,then%20the%20order%20remains%20unchanged.
import xmltodict
import dicttoxml
from xml.dom.minidom import parseString
import importlib
import json
import iso639
import urllib
import pandas as pd

# GLOBAL CONSTANTS
# definied outside a class instance to be available to all methods but invisible to the user
NAMES_METADATA = ("@context", "@type", "additionalMetadata", "dataset", "packageId", "schemaLocation", "system") # top-level elements, determined by examining R object produced by EML::read_eml()
NAMES_METADATA_CONTEXT = ("@vocab", "eml", "xsi", "xml", "stmml", "id", "@base")
CUI_CHOICES = {
    'PUBLIC': 'Contains CUI. Only federal employees should have access (similar to "internal only" in DataStore)',
    'NOCON': 'Contains  CUI. Federal, state, local, or tribal employees may have access, but contractors cannot.',
    'DL_ONLY': 'Contains CUI. Should only be available to a names list of individuals (where and how to list those individuals TBD)',
    'FEDCON': 'Contains CUI. Only federal employees and federal contractors should have access (also very much like current "internal only" setting in DataStore)',
    'FED_ONLY': 'Contains CUI. Only federal employees should have access (similar to "internal only" in DataStore)'
}
INT_RIGHTS_CHOICES = ('CC0', 'public', 'restricted')
CURRENT_RELEASE = '0.0.1'
APP_NAME = "pyEML"
LICENSE_TEXT = {
                    'CCzero': 'This product is released to the "public domain" under Creative Commons CC0 1.0 No Rights Reserved (see: https://creativecommons.org/publicdomain/zero/1.0/).',
                    'pub_domain': 'This product is released to the "public domain" under U.S. Government Works No Rights Reserved (see: http://www.usa.gov/publicdomain/label/1.0/).',
                    'restrict': 'This product has been determined to contain Controlled Unclassified Information (CUI) by the National Park Service, and is intended for internal use only. It is not published under an open license. Unauthorized access, use, and distribution are prohibited.'
        }
NPS_DOI_ADDRESS = 'https://doi.org/10.57830/'

class Emld():
    """An object that holds metadata extracted from an EML-formatted xml file"""
    
    def __init__(self, filepath:str, NPS:bool = True):
        """Constructor for class Emld"""
        # @param filepath
            # a string containing the filepath and filename, including file extension, of the .xml file generated by EML
            # valid EML is usually generated from an R tool like library(EML)
        # @param NPS
            # default True
            # True indicates NPS is the author of this EML [meta]data package
            # True executes two private methods during the `_add_required()` call:
                # 1. `_set_by_for_nps()`
                # 2 `_set_npspublisher()`
            
        # validate user input
        assert filepath != "", "File cannot be blank"
        assert filepath.lower().endswith(".xml"), "File must end with '.xml'"
        assert NPS in (True, False), "Parameter `NPS` must be either True or False."
        
        # procedure
        try:
            # read user-provided xml to dictionary for parsing
            with open(filepath, 'r', encoding='utf-8') as file:
                py_xml = file.read()
                my_dict = xmltodict.parse(py_xml)
            
            # create empty dictionary with correct element names
            self.emld = OrderedDict(zip(NAMES_METADATA, [None]*len(NAMES_METADATA))) # empty metadata object with named & ordered elements
            self.emld["@context"] = dict(zip(NAMES_METADATA_CONTEXT, [None]*len(NAMES_METADATA_CONTEXT))) # add sub-elements to metadata object
            
            '''Parse user-provided xml to dictionary'''
            # Assign a value to self.emld["@context"]["@vocab"]
            if my_dict["eml:eml"]["@xmlns:eml"][-1:] != '/':
                self.emld["@context"]["@vocab"] = my_dict["eml:eml"]["@xmlns:eml"] + '/' 
            else:
                self.emld["@context"]["@vocab"] = my_dict["eml:eml"]["@xmlns:eml"]
                
            # Assign a value to self.emld["@context"]["eml"]
            if my_dict["eml:eml"]["@xmlns:eml"][-1:] != '/':
                self.emld["@context"]["eml"] = my_dict["eml:eml"]["@xmlns:eml"] + '/' 
            else:
                self.emld["@context"]["eml"] = my_dict["eml:eml"]["@xmlns:eml"]
                
            # Assign a value to self.emld["@context"]["xsi"]
            if my_dict["eml:eml"]["@xmlns:xsi"][-1:] != '/':
                self.emld["@context"]["xsi"] = my_dict["eml:eml"]["@xmlns:xsi"] + '/' 
            else:
                self.emld["@context"]["xsi"] = my_dict["eml:eml"]["@xmlns:xsi"]
              
            self.emld["@context"]["xml"] = "http://www.w3.org/XML/1998/namespace" # Assign a value to self.emld["@context"]["xml"]
            '''
            ["@context"]["xml"] is hard-coded because 1998 does not exist in the original xml and I haven't been able to trace where emld::as_emld() is pulling this value from.
            emld::as_emld() defines namespaces by calling emld::eml_ns() which is defined at line 50 here: https://github.com/ropensci/emld/blob/master/R/eml_version.R
            1998 is not defined (i.e., hard-coded) in emld::eml_ns(), which tells me it's not a default value defined in the package library(emld)
            1998 is also not present in the original xml `r_original_xml` or `py_xml` for emld::eml_ns() to point to (i.e., `grepl("1998", as.character(r_original_xml)) == FALSE`)
            which tells me emld::as_emld() isn't pulling this value from the user-provided xml
            the remaining option is that emld::as_emld() is pointing to a remote for this value
            Since I haven't traced where this remote is located,
            I have no choice but to hard-code this value until I can figure out how library(emld) is finding a value for ["@context"]["xml"].
            '''
            self.emld["@context"]["stmml"] = my_dict["eml:eml"]["@xmlns:stmml"] # Assign a value to self.emld["@context"]["stmml"]
            self.emld["@context"]["id"] = "@id" # Assign a value to self.emld["@context"]["id"]
            self.emld["@context"]["@base"] = "eml://" # Assign a value to self.emld["@context"]["@base"]
            self.emld["dataset"] = my_dict["eml:eml"]["dataset"] # Assign a value to self.emld["dataset"]
            self.emld["additionalMetadata"] = my_dict["eml:eml"]["additionalMetadata"] # Assign a value to self.emld["additionalMetadata"]
            self.emld["packageId"] = my_dict["eml:eml"]["@packageId"] # Assign a value to self.emld["packageId"]
            self.emld["schemaLocation"] = my_dict["eml:eml"]["@xsi:schemaLocation"] # Assign a value to self.emld["schemaLocation"]
            self.emld["system"] = my_dict["eml:eml"]["@system"] # Assign a value to self.emld["schemaLocation"]
            self.emld["@type"] = "EML" # Assign a value to self.emld["@context"]["@base"]
            
            self.NPS = NPS # save this value to pass
            self._add_required()
            
            print("Emld instance created!\n") # print success message
        except:
            print("An error occurred and your Emld did not instantiate.")
            
    def set_cui(self, cui_code:str = CUI_CHOICES, force:bool = False):
        '''Set the data package's controlled unclassified information (CUI) status'''
        # @param cui_code a string consisting of one of 7 potential CUI codes (defaults to "PUBFUL").
            # FED_ONLY - Contains CUI. Only federal employees should have access (similar to "internal only" in DataStore)
            # FEDCON - Contains CUI. Only federal employees and federal contractors should have access (also very much like current "internal only" setting in DataStore)
            # DL_ONLY - Contains CUI. Should only be available to a names list of individuals (where and how to list those individuals TBD)
            # NOCON - Contains  CUI. Federal, state, local, or tribal employees may have access, but contractors cannot.
            # PUBLIC - Does NOT contain CUI.
        # @param force bool
            # Default False
            # True means the program will over-write any value in <metadata><CUI> if one exists or create that tag and add `cui_code` if !exists
            # False prints the value of <metadata><CUI> to console and asks the user to decide to over-write or not

        # saving in case I need to pivot to xml instead of dict
        # https://www.geeksforgeeks.org/turning-a-dictionary-into-xml-in-python/

        # verify CUI code entry; stop if does not equal one of six valid codes listed above:
        assert cui_code in CUI_CHOICES, print(f'You must choose a `cui_code` from the pick-list:\n{self.describe_cui()}')
        assert force in (True, False), "Parameter `force` must be either True or False."

        # procedure
        try:
            if force == True:
                # self.emld["additionalMetadata"]["metadata"]['@id'] = "CUI" # set the value of attribute "id" in <additionalMetadata id=fill_in_the_blank> with "CUI"
                self.emld["additionalMetadata"]["metadata"]["CUI"] = cui_code   # set the value of <metadata><CUI>
                print(f"Value of `CUI` set to '{cui_code}'!")
            else:
                pass
        except:
            print("CUI did not update.")
            
    def describe_cui(self):
        '''Print the `CUI` (controlled unclassified information) choices to console'''
        
        print(f'`CUI` means controlled unclassified information. The following `CUI` choices are available in this release of {APP_NAME}:')
        print('----------')
        for k, v in CUI_CHOICES.items():
            print(f'\'{k}\': {v}\n')
        

    def set_title(self, data_package_title:str, force:bool = False):
        '''Set the title of the data package'''
        # @param data_package_title str
            # The title the user wants to change their data package title to
            # e.g., data_package_title = "My new title"
        # @param force bool
            # Default False
            # True means the program will over-write any value in <metadata><CUI> if one exists or create that tag and add `cui_code` if !exists
            # False prints the value of <metadata><CUI> to console and asks the user to decide to over-write or not
            
        # validate user input
        assert data_package_title != "", "Parameter `data_package_title` cannot be blank"
        assert force in (True, False), "Parameter `force` must be either True or False."
        
        # procedure
        try:
            if force == True:
                self.emld["dataset"]["title"] = data_package_title # set the value of attribute "title"
                print(f"Value of dataset title set to '{data_package_title}'!")
            if force == False:
                if self.emld["dataset"]["title"] != None:
                    print(f'Your dataset already has a title: {self.emld["dataset"]["title"]}')
                    user_choice = input("Do you want to overwrite your original title?\n'y' then enter to overwrite or 'n' then enter to keep original title\n\n")
                    if user_choice != 'y':
                        pass
                    else:
                        self.emld["dataset"]["title"] = data_package_title
                        print(f"You overwrote your original data package title to '{data_package_title}'!")
        except:
            print("Title did not update.")
        
    def set_int_rights(self, license:str = INT_RIGHTS_CHOICES, force:bool = False):
        '''Set the intellectual property rights of the data package'''
        # @param license str
            # The intellectual rights the user wants to set for their data package
            # e.g., license = "public"
        # @param force bool
            # Default False
            # True means the program will over-write any value in ["dataset"]["intellectualRights"] if one exists or create add value if !exists
            # False prints the value of ["dataset"]["intellectualRights"] to console and asks the user to decide to over-write or not
        
        # validate user input
        assert license != "", "Parameter `license` cannot be blank"
        assert license in INT_RIGHTS_CHOICES
        assert force in (True, False), "Parameter `force` must be either True or False."

        # procedure
        try:
            if "CUI" not in self.emld["additionalMetadata"]["metadata"]:
                print("This data package's controlled unclassified information status, `CUI`, must be set before setting the package's intellectual property rights.\n")
                print("First, use the `set_cui()` method to set your dataset's `CUI`.")
                print("Then, re-try the `set_int_rights()` method to set your dataset's intellectual property rights.")
                pass
            else:
                print(f'`CUI` value in data package was: \'{self.emld["additionalMetadata"]["metadata"]["CUI"]}\'.\n')
                if self.emld["additionalMetadata"]["metadata"]["CUI"] == 'PUBLIC': # Public CUI has two acceptable license choices: 'CC0' and 'pub_domain'
                    if license == 'CC0':
                        self.emld["dataset"]["intellectualRights"] = LICENSE_TEXT["CCzero"]
                        print(f'Data package `intellectual rights` set to {license}!')
                    elif license == 'public':
                        self.emld["dataset"]["intellectualRights"] = LICENSE_TEXT["pub_domain"]
                        print(f'Data package `intellectual rights` set to {license}!')
                    else:
                        print(f'Assigning \'{license}\' as your data package\'s intellectual rights will contradict your data package\'s controlled unclassified information `CUI` status of {self.emld["additionalMetadata"]["metadata"]["CUI"]}.\n')
                        print('To resolve this conflict, you must make your data package\'s `CUI` and `intellectual_rights` agree.\n')
                        print('If you really want to restrict intellectual rights on your data package, use the `set_cui()` method to set `CUI` to "NOCON", "DL_ONLY", "FEDCON", or "FED_ONLY" and then re-try `set_int_rights()`.')
                        print('If your dataset will be published to the public, its intellectual rights must be public-facing (i.e., \'CCO\' or \'public\').')
                else:
                    if licence == 'restrict':
                        self.emld["dataset"]["intellectualRights"] = LICENSE_TEXT["restrict"]
                        print(f'Data package `intellectual rights` set to {license}!')
                    else:
                        print(f'Assigning \'{license}\' as your data package\'s intellectual rights will contradict your data package\'s controlled unclassified information `CUI` status of {self.emld["additionalMetadata"]["metadata"]["CUI"]}.')
                        print('To resolve this conflict, you must make your data package\'s `CUI` and `intellectual_rights` agree.\n')
                        print('If you really want to restrict intellectual rights on your data package, use the `set_cui()` method to set `CUI` to "NOCON", "DL_ONLY", "FEDCON", or "FED_ONLY" and then re-try `set_int_rights()`.')
                        print('If your dataset will be published to the public, its intellectual rights must be public-facing (i.e., \'CCO\' or \'public\').')
        except:
            print('An error occurred when attempting to set data package intellectual rights.')
            print('This error can only occur from the data package having an unacceptable `CUI` or `license` value.')
            print('Check your data package\'s `CUI` and the `license` that you provided this method.')
   
    def describe_int_rights(self):
        '''Print the `intellectual rights` choices to console'''
        
        print(f'The following `intellectual rights` choices are available in this release of {APP_NAME}:')
        print('----------')
        for k, v in LICENSE_TEXT.items():
            print(f'\'{k}\': {v}\n')
    
    def _set_npspublisher(self):
        '''Set the publisher for the dataset'''
        
        PUBSET = {
            'organizationName': 'National Park Service',
            'address': {
                'deliveryPoint': '1201 Oakridge Drive, Suite 150',
                'city': 'Fort Collins',
                'administrativeArea': 'CO',
                'postalCode': '80525',
                'country': 'USA'
            },
            'onlineUrl': 'http://www.nps.gov',
            'electronicMailAddress': 'irma@nps.gov',
            'userId': {
                'directory': 'https://ror.org/',
                'userId': "https://ror.org/044zqqy65"
            }
        }
        
        # try:
        #     self.emld["dataset"]["publisher"]
        #     print(f'the publisher is {self.emld["dataset"]["publisher"]}')
        #     if self.emld["dataset"]["publisher"] != PUBSET:
        #         self.emld["dataset"]["publisher"] = PUBSET
        # except:
        #     print("Your dataset had no publisher")
        #     self.emld["dataset"]["publisher"] = PUBSET
        #     print("Your dataset's publisher has been set to the NPS default: Fort Collins IRMA")
        
        # The R version of this function is designed to ensure that the dataset always ends up with the values of `PUBSET`.
        # That version checks whether ["dataset"]["publisher"] matches `PUBSET` and then re-assigns the values if they don't match
        # Since the goal of this function is to set ["dataset"]["publisher"] to `PUBSET` I just skipped that logic
        # line 15 https://github.com/nationalparkservice/EMLeditor/blob/main/R/utils.R
        self.emld["dataset"]["publisher"] = PUBSET
        
    def _set_for_by_nps(self):
        '''Set the value of ["additionalMetadata"]["metadata"]["agencyOriginated"]'''
        
        # delete context attribute from ["additionalMetadata"]
        try: # not sure why this is necessary but line 167 does this https://github.com/nationalparkservice/EMLeditor/blob/main/R/utils.R
            del self.emld["additionalMetadata"]["@context"] # delete if it exists
        except:
            pass
        
        # constants
        FOR_BY = { # i.e., the "whole deal"
            'metadata': {
                'agencyOriginated': {
                    'agency': "NPS",
                    'byOrForNPS': "TRUE"
                }
            }
        }
        FOR_BY2 = { # i.e., a shortened version of the "whole deal"
                'agency': "NPS",
                'byOrForNPS': "TRUE"
            }
        
        # procedure
        addl_md_len = len(self.emld["additionalMetadata"]) # variable to track length
        if "agencyOriginated" in self.emld["additionalMetadata"]["metadata"]: # check dict keys
            pass # if agencyOriginated is already there, this step is already done so skip
        else: # otherwise, our next step depends on what's already there
            if addl_md_len == 0: # if ["additionalMetadata"] is empty
                # print("len = 0")
                self.emld["additionalMetadata"] = FOR_BY # add the whole deal
            else:
                # print("len >= 1")
                self.emld['additionalMetadata']["metadata"]["agencyOriginated"] = FOR_BY2 # add a shortened version of the whole deal
    
    def set_doi(self, ds_ref:str, force:bool = False):
        '''Set the data package's DOI'''
        
        # @param ds_ref str
            # the same as the 7-digit reference code generated on DataStore when a draft reference is initiated.
            # e.g., license = "public"
        # @param force
            # Default False
            # False will overwrite existing doi values or create a new doi value if !exists
        
        # validate user input
        assert len(ds_ref) == 7, 'A valid data package DOI is seven characters long; check the DOI you provided as `ds_ref`.'
        assert ds_ref.isnumeric() == True, 'A valid data package DOI contains only numbers; check the DOI you provided as `ds_ref`.'
        assert force in (True, False), "Parameter `force` must be either True or False."
        
        # procedure
        try:
            if force == True:
                print("got to force = true")
                self.emld["dataset"]["alternateIdentifier"] = 'doi: ' + NPS_DOI_ADDRESS + ds_ref
            else:
                if 'alternateIdentifier' in self.emld["dataset"]:
                    print(f'This data package has currently has a doi of \'{self.emld["dataset"]["alternateIdentifier"]}\'.')
                    user_choice = input("Do you want to overwrite your original doi?\n'y' then enter to overwrite or 'n' then enter to keep original doi\n\n")
                    if user_choice != 'y':
                        print(f'You chose to keep the dataset\'s original doi: \'{self.emld["dataset"]["alternateIdentifier"]}\'')
                        pass
                    else:
                        self.emld["dataset"]["alternateIdentifier"] = 'doi: ' + NPS_DOI_ADDRESS + ds_ref
                        print(f'You overwrote the data package\'s doi to: \'{NPS_DOI_ADDRESS + ds_ref}\'!')
                else:
                    print(f'No alternate identifier (doi) was found in dataset. Updating to \'{ds_ref}\' now...')
                    self.emld["dataset"]["alternateIdentifier"] = 'doi: ' + NPS_DOI_ADDRESS + ds_ref
                    print(f'Dataset doi updated to \'{NPS_DOI_ADDRESS + ds_ref}\'!')
        except:
            print('Unable to set data package doi.\n')
            print('Check the current value of your data package\'s `alternateIdentifier` and the `ds_ref` that you provided.')
                    
                    
    def set_drr(self, drr_ref_id:str, drr_title:str, org_name:str = 'NPS', force = False):
        '''Set the value of the dataset's DRR'''
        
        # @param drr_ref_id
            # A 7-digit string that is the DataStore Reference ID for the DRR associated with the data package.
        # @param drr_title
            # The title of the DRR as it appears in the DataStore Reference.
        # @param org_name
            # Default 'NPS'
            # If the organization publishing the DRR is *not* NPS, set org_name to your publishing organization's name.
        # @param force
            # Default False
            # False will overwrite existing values and/or create key-value pairs if necessary
            
        # @examples
            # drr_title = 'Data Release Report for Data Package 1234'
            # myemld.set_drr(drr_ref_id = '2293234', drr_title = drr_title)
        
        # validate user input
        assert len(drr_ref_id) == 7, 'A valid data package DataStore Reference is seven characters long; check the DOI you provided as `drr_ref_id`.'
        assert force in (True, False), "Parameter `force` must be either True or False."
        
        # procedure
        if 'creator' in self.emld["dataset"]:
            CREATOR = self.emld["dataset"]["creator"]
        else:
            CREATOR = {
                'organization': org_name
            }
        
        USAGE_CITATION = {
            'alternateIdentifier': 'DRR: https://doi.org/10.36967/' + drr_ref_id,
            'title': drr_title,
            'creator': CREATOR,
            'report': drr_ref_id,
            'id': 'associatedDRR'
        }
        
        try:
            if force == True:
                if 'usageCitation' in self.emld["dataset"]:
                    print(f'Your dataset originally had a DRR of:')
                    print('----------')
                    print(json.dumps(self.emld["dataset"]["usageCitation"], indent=4, default=str))
                    print('----------')
                    print('Choosing `force` = True overwrote to:')
                    print('----------')
                    self.emld["dataset"]["usageCitation"] = USAGE_CITATION
                    print(json.dumps(self.emld["dataset"]["usageCitation"], indent=4, default=str))
                    print('----------')
            else:
                if 'usageCitation' not in self.emld["dataset"]:
                    print('No existing DRR information found in this dataset.')
                    print('Writing DRR information to dataset...')
                    self.emld["dataset"]["usageCitation"] = USAGE_CITATION
                    print('New DRR information:')
                    print('----------')
                    print(json.dumps(self.emld["dataset"]["usageCitation"], indent=4, default=str))
                else:
                    print('Existing DRR information was found in this dataset:')
                    print('----------')
                    print(json.dumps(self.emld["dataset"]["usageCitation"], indent=4, default=str))
                    print('----------')
                    print('Do you want to over-write the existing DRR information?')
                    user_choice = input('Do you want to over-write the existing DRR information?\n\'y\' then enter to overwrite or \'n\' then enter to keep original title\n\n')
                    if user_choice != 'y':
                        print(f'User input: \'{user_choice}\'')
                        print('You chose to keep your data package\'s existing DRR information.')
                        pass
                    else:
                        self.emld["dataset"]["usageCitation"] = USAGE_CITATION
                        print(f"User input: \'{user_choice}'\. You overwrote your original data package DRR to:")
                        print('----------')
                        print(json.dumps(self.emld["dataset"]["usageCitation"], indent=4, default=str))
                        print('----------')
        except:
            print("Unable to update dataset DRR.")
            print("Check the parameters provided to `set_drr()` for accuracy.")
            pass
        
    def set_language(self, language:str = 'English', force:bool = False):
        '''Specify the language that the data package was constructed in.'''
        
        # @param language
            # Default 'English'
            # The English words for the language the data and metadata were constructed in (e.g. 'English' or 'Spanish').
            # User input is automatically converted to the the 3-letter codes for languages listed in ISO 639-2
            # (available at https://www.loc.gov/standards/iso639-2/php/code_list.php) and inserted into the metadata.
        # @param force
            # Default False
            # False will overwrite existing values and/or create key-value pairs if necessary
        
        # @examples
            # myemld.set_language(language = 'english', force = True)
            # myemld.set_language(language = 'SpAnISh', force = True)
            # myemld.set_language(language = 'Navajo', force = True)
            
        # validate user input
        assert force in (True, False), "Parameter `force` must be either True or False."
        
        # procedure
        language_title = language.title() # enforce ISO capitalization
        if language_title == 'Spanish':
            language_title = 'Spanish; Castilian'
        if language_title == 'Iroquois':
            language_title = 'Iroquoian languages'
            
        try:
            language_obj = iso639.languages.get(name = language_title)
            if language_obj is None:
                print(f'\'{language}\' was not found in the ISO 639-2 database.')
                print('https://www.loc.gov/standards/iso639-2/php/code_list.php')
                print('Please provide `set_language()` with a language name present in the ISO 639-2 \'English name of Language\' column.')
            else:
                language_title = language_obj.part3
                if len(language_title) != 3:
                    print('language length error')
                    print('An error occurred when parsing the language to its ISO code.')
                else:
                    if force == True:
                        self.emld["dataset"]["language"] = language_title
                        print(f'Dataset language set to {language_title}!')
                    else:
                        print('ended up in else block')
                        if 'language' in self.emld["dataset"]:
                            print(f'The dataset\'s language is currently \'{self.emld["dataset"]["language"]}\'')
                            user_choice = input("Do you want to overwrite the dataset's current language?\n'y' then enter to overwrite or 'n' then enter to keep original doi\n\n")
                            if user_choice != 'y':
                                print(f'User input: {user_choice}')
                                print(f'You chose to keep the dataset\'s original language: \'{self.emld["dataset"]["language"]}\'')
                            else:
                                print(f'User input: {user_choice}')
                                self.emld["dataset"]["language"] = language_title
                                print(f'You overwrote the data package\'s language to: \'{self.emld["dataset"]["language"]}\'!')
                        else:
                            self.emld["dataset"]["language"] = language_title
                            print(f'Dataset language set to {language_title}!')
        except:
            print(f'\'{language}\' was not found in the ISO 639-2 database.')
            print('https://www.loc.gov/standards/iso639-2/php/code_list.php')
            print('Please provide `set_language()` with a language name present in the ISO 639-2 \'English name of Language\' column.')
        
    def set_content_units(self, *unit_code:str, force:bool = False, verbose:bool = False):
        '''Get the decimal degree gps coordinates for a park polygon.'''
        
        # @param *unit_code
            # * indicates an 'arbitrary' argument, meaning the parameter takes any number of comma-separated arguments
            # Each argument is the four-character location code for one National Park Service location
            # https://irmaservices.nps.gov/v2/rest/unit/
        # @param force
            # Default False
            # False will overwrite existing values and/or create key-value pairs if necessary
        # @param verbose
            # Default False
            # True prints before & after dataset content units; could be lengthy, depending how many parks are in `unit_code`
            
        # @examples
            # If your Parks were: GLAC: Glacier National Park; ACAD: Acadia National Park
            # myemld.set_content_units('GLAC', 'ACAD')
        
        # for code in unit_code:
        #     print(f'User entered code: {code} with length {len(code)}.')
        
        # # validate user input
        assert force in (True, False), "Parameter `force` must be either True or False."
        assert verbose in (True, False), "Parameter `verbose` must be either True or False."
        for code in unit_code:
            assert len(str(code)) == 4, print(f'Unit code {str(code)} is not four characters in length. Review for accuracy and try again.')

        # procedure
        # An API call to NPS Rest Services to get
        try:
            polygon_holder = dict() # decimal degrees of all polygon points for each `unit_code`
            bbox_holder = dict() # bounding box (max & min lat & lon) for each `unit_code`
            geog_cov = dict() # the bounding box(es) in the format that EML requires
            for unit in unit_code:
                # loop over each unit in `unit_code`
                api_url = 'https://irmaservices.nps.gov/v2/rest/unit/' + str(unit) + '/geography'
                print(f'API call for {str(unit)}... {api_url}')
                contents = urllib.request.urlopen(api_url).read()
                contents = xmltodict.parse(urllib.request.urlopen(api_url).read())
                contents = contents["ArrayOfUnitGeography"]["UnitGeography"]["Geography"]
                contents = contents.replace(',', '').replace('\']', '').replace('[\'', '').replace('POLYGON ((', '').replace('))', '').split()
                park_geom = pd.DataFrame()
                park_geom["lat"] = contents[1::2] # Elements from list1 starting from 1 iterating by 2
                park_geom["lon"] = contents[::2]
                polygon_holder[unit] = park_geom
                # split into decimal degree bounding box
                bbox_holder[unit] = {
                'N': max(polygon_holder[unit]["lat"]),
                'E': min(polygon_holder[unit]["lon"]),
                'S': min(polygon_holder[unit]["lat"]),
                'W': max(polygon_holder[unit]["lon"])
                }
                # build EML geographic coverage dict for each unit
                geog_cov[unit] = {
                  'geographicDescription': 'NPS Content Unit Link: ' + unit,
                  'boundingCoordinates': {
                      'northBoundingCoordinate': bbox_holder[unit]["N"],
                      'eastBoundingCoordinate': bbox_holder[unit]["E"],
                      'southBoundingCoordinate': bbox_holder[unit]["S"],
                      'westBoundingCoordinate': bbox_holder[unit]["W"]
                    }
                }
                # print('----------')
                # print(f'API call return for {unit}:')
                # print('----------')
                # print(json.dumps(geog_cov[unit], indent=4, default=str))
                # print('----------\n')
            if force == True:
                if verbose == True:
                    print('----------')
                    print(f'Original content unit(s) for dataset:')
                    print('----------')
                    print(json.dumps(self.emld["dataset"]["coverage"]["geographicCoverage"], indent=4, default=str))
                    print('----------\n')
                    print('----------')
                    print(f'Updated content units for dataset:')
                    self.emld["dataset"]["coverage"]["geographicCoverage"] = geog_cov
                    print('----------')
                    print(json.dumps(self.emld["dataset"]["coverage"]["geographicCoverage"], indent=4, default=str))
                    print('----------\n')
                else:
                    self.emld["dataset"]["coverage"]["geographicCoverage"] = geog_cov
                    print(f'Dataset content units updated for {str(unit_code)}!')
            else:
                pass
                
        except NameError as e:
            print('An error prevented your unit codes from processing.')
            print(e)
            print('Please check your unit codes for accuracy and try again.')
        except TypeError as t:
            print('You entered a unit code of the wrong type.')
            print(t)
            print('Please check your unit codes for accuracy and try again.')
            
    def set_abstract(self, abstract:str, force:bool = False):
        '''Set the dataset's abstract.'''
        
        # @param abstract
            # One or more sentences summarizing what is in the dataset.
            # An abstract is a short summary of what is in the dataset.
        # @param force
            # Default False
            # False will overwrite existing values and/or create key-value pairs if necessary
            
        # @examples
            # my_abstract = 'This is the first sentence that describes my dataset. This is another sentence about the dataset.'
            # myemld.set_abstract(abstract = myabstract, force = True)
            
        # validate user input
        assert force in (True, False), "Parameter `force` must be either True or False."
        
        # procedure
        try:
            if force == True:
                self.emld["dataset"]["abstract"] = abstract
                print(f'Your abstract was updated to:')
                print('----------')
                print(f'{abstract}')
                print('----------')
            else:
                if 'abstract' in self.emld["dataset"]:
                            print(f'The dataset\'s abstract is currently \'{self.emld["dataset"]["abstract"]}\'')
                            user_choice = input(f"The dataset\'s abstract is currently '{self.emld['dataset']['abstract']}\nDo you want to overwrite the dataset's current abstract?\n'y' then enter to overwrite or 'n' then enter to keep original doi\n\n")
                            if user_choice != 'y':
                                print(f'User input: {user_choice}')
                                print(f'You chose to keep the dataset\'s original abstract: \'{self.emld["dataset"]["abstract"]}\'')
                            else:
                                print(f'User input: {user_choice}')
                                self.emld["dataset"]["abstract"] = abstract
                                print(f'You overwrote the data package\'s abstract to: \'{self.emld["dataset"]["abstract"]}\'!')
                    
        except NameError as e:
            print('An error prevented your abstract from processing.')
            print(e)
            print('Please check your argument for accuracy and try again.')
        except TypeError as t:
            print('You entered an argument of the wrong type.')
            print(t)
            print('Please check your argument for accuracy and try again.')
    
    def _set_version(self):
        '''Set the value of `app` and `release`.'''
        
        # delete context attribute from ["additionalMetadata"]
        try: # not sure why this is necessary but line 167 does this https://github.com/nationalparkservice/EMLeditor/blob/main/R/utils.R
            del self.emld["additionalMetadata"]["@context"] # delete if it exists
        except:
            pass
        
        # constants
        VERSION = {
                'app': APP_NAME,
                'release': CURRENT_RELEASE
            }
        
        # procedure
        if "emlEditor" in self.emld["additionalMetadata"]["metadata"]: # check dict keys
            # the R version of EMLeditor inherits the naming convention EMLassemblyline for <emlEditor> tags
            # this is confusing because our R and py packages are called EMLeditor but EMLassemblyline is routed to the <emlEditor> tag along with EMLeditor to <emlEditor id="EMLeditor">
            # this namespace conflict is a problem in py dict{} and R list and the R version of EMLeditor works around this by assigning
            # un-named list elements to allow for duplicated list element names (i.e., duplicated keys in a dict).
            # To work around this, I re-assign EMLassebmlyline's ["emlEditor"] to a key called ["emlSource"]
            # thereby freeing up the ["emlEditor"] namespace to hold information about `EMLeditor` release versions
            # ["emlSource"] eventually needs to become tag <emlEditor> with no id attribute
            # ["emlEditor"] eventually needs to become tag <emlEditor id="EMLeditor">
            self.emld['additionalMetadata']["metadata"]["emlSource"] = self.emld['additionalMetadata']["metadata"]["emlEditor"]
            del self.emld['additionalMetadata']["metadata"]["emlEditor"] # delete to free up namespace for `_set_version()`
        
        self.emld["additionalMetadata"]["metadata"]["emlEditor"] = VERSION # add version info
        print(f"")
    
    def _add_required(self):
        '''A method that enforces class Emld data requirements'''
        
        '''
        Several functions in R EMLeditor::editEMLfunctions.R (examples below) silently execute functions from EMLeditor::utils.R.
        Those hidden functions silently apply required standards to the dataset provided by a user (e.g., filling in required fields,
        like `publisher`, that the "valid EML" doesn't require but NPS does require, so earlier EML/XML validation does not enforce on user data).
        Hiding a function call inside another function and silently
        executing the hidden function is an unnecessarily convoluted way of enforcing the class rules on user data.
        
        Instead, I'm calling a method that executes these required data package changes
        from the class's `__init__()` method.
        A. This enforces the "rules" of a class instance on instantiation.
        B. It's also easier to maintain code when functions do one thing.
        
        Examples of R EMLeditor functions that update elements from other function calls:
        `set_title()` line 18 calls .set_npspublisher()` line 52 and `set_version()` line 55 https://github.com/nationalparkservice/EMLeditor/blob/main/R/editEMLfunctions.R
        `set_doi()` line 73 calls `.set_npspublisher()` line 152 and `.set_version()` line 156 https://github.com/nationalparkservice/EMLeditor/blob/main/R/editEMLfunctions.R
        `set_content_units()` line 178 calls `.set_npspublisher()` line 412 and `.set_version()` line 416 https://github.com/nationalparkservice/EMLeditor/blob/main/R/editEMLfunctions.R
        ctrl+f for ".set" shows 25 calls of hidden functions from other functions in EMLeditor::editEMLfunctions.R
        '''
        
        # procedure
        if self.NPS == True:
            self._set_npspublisher() # set publisher if NPS
            self._set_for_by_nps() # set for-by if NPS
        self._set_version() # set version regardless
        
    def write_eml(self, destination_filename:str, attr_type:bool = False):
        '''Write emld to .xml'''
        # @param destination_filename
            # the name and filepath, including the .xml file extension, where the Emld.emld should be saved
        # @param attr_type
            # default value is False
            # True adds an attribute to every xml tag that specifies the data type stored in that tag
            # e.g., If a tag holds string data (str), its tag might be this: <mytag type="str">
            # False omits the attribute tag like this: <mytag>
            
        # validate user input
        assert destination_filename != "", "File cannot be blank"
        assert destination_filename.lower().endswith(".xml"), "File must end with '.xml'"
        assert attr_type in (True, False), "Parameter `attr_type` must be either True or False."
        
        # procedure
        try:
            xmloutput = dicttoxml.dicttoxml(self.emld, attr_type = attr_type)
            xml_decode = xmloutput.decode()
            xmlfile = open(destination_filename, "w")
            xmlfile.write(xml_decode)
            xmlfile.close()
        except:
            print("Unable to write eml to xml.")
        
    def print_eml(self, attr_type:bool = False):
        '''Pretty-print xml to console'''
        # @param attr_type
            # default value is False
            # True adds an attribute to every xml tag that specifies the data type stored in that tag
            # e.g., If a tag holds string data (str), its tag might be this: <mytag type="str">
            
        # validate user input
        assert attr_type in (True, False), "Parameter `attr_type` must be either True or False."
        
        # procedure
        try:
            xmloutput = dicttoxml.dicttoxml(self.emld, attr_type = attr_type)
            print(parseString(xmloutput).toprettyxml())
            # eventually, update to:
            # print(xmltodict.unparse(myemld.emld["additionalMetadata"], pretty=True))
        except:
            print("error in printing eml")
            
        '''
        Eventually, we're going to need to adjust the way we print tag attributes to match the EML spec.
        We need to duplicate <additionalMetadata><metadata> tags from myemld.emld["additionalMetadata"]["metadata"] to look like this:
            
        <additionalMetadata id="CUI">
            <metadata>
                <CUI>PUBLIC</CUI>
            </metadata>
        </additionalMetadata>
        <additionalMetadata>
            <metadata>
                <emlEditor>
                    <app>EMLassemblyline</app>
                    <release>3.5.5</release>
                </emlEditor>
            </metadata>
        </additionalMetadata>
        
        Our current data structure would omit the id attribute and fail to duplicate tags and would look like this:
            
        <additionalMetadata>
            <metadata>
                <CUI>PUBLIC</CUI>
                <emlEditor>
                    <app>EMLassemblyline</app>
                    <release>3.5.5</release>
                </emlEditor>
            </metadata>
        </additionalMetadata>
        
        To overcome this, we'll duplicate tags and assign attribute "id" a value by looping over our dictionary like this:
        for thing in myemld.emld["additionalMetadata"]["metadata"]:
            if thing != 'emlEditor':
                print(thing)
        where a "thing" is the value of the `id` attribute and we duplicate <additionalMetadata><metadata> len(myemld.emld["additionalMetadata"]["metadata"]) times
        in R we accomplish this with a for loop and xml2::xml_add_child() and xml2::xml_set_attr()
        in python it seems like we use the append method... https://stackoverflow.com/questions/43883650/insert-xml-string-from-a-dicttoxml-object-into-a-lxml-etree
        '''
    

