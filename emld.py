# a constructor for class Emld

from collections import OrderedDict # https://realpython.com/python-ordereddict/#:~:text=Python's%20OrderedDict%20is%20a%20dict,then%20the%20order%20remains%20unchanged.
import xmltodict
import dicttoxml
from xml.dom.minidom import parseString

# define static assets outside of class instances
NAMES_METADATA = ("@context", "@type", "additionalMetadata", "dataset", "packageId", "schemaLocation", "system") # top-level elements, determined by examining R object produced by EML::read_eml()
NAMES_METADATA_CONTEXT = ("@vocab", "eml", "xsi", "xml", "stmml", "id", "@base")

class Emld():
    """An object that holds metadata extracted from an EML-formatted xml file"""
    
    def __init__(self, filepath:str):
        """Constructor for class Emld"""
        # @param filepath
            # a string containing the filepath and filename, including file extension, of the .xml file generated by EML
            # valid EML is usually generated from an R tool like library(EML)
            
        # validate user input
        assert filepath != "", "File cannot be blank"
        assert filepath.lower().endswith(".xml"), "File must end with '.xml'"
        
        # procedure
        try:
            # read user-provided xml to dictionary for parsing
            with open(filepath, 'r', encoding='utf-8') as file:
                py_xml = file.read()
                my_dict = xmltodict.parse(py_xml)
            
            # create empty dictionary with correct element names
            self.emld = OrderedDict(zip(NAMES_METADATA, [None]*len(NAMES_METADATA))) # empty metadata object with named & ordered elements
            self.emld["@context"] = dict(zip(NAMES_METADATA_CONTEXT, [None]*len(NAMES_METADATA_CONTEXT))) # add sub-elements to metadata object
            
            '''Parse user-provided xml to dictionary'''
            # Assign a value to self.emld["@context"]["@vocab"]
            if my_dict["eml:eml"]["@xmlns:eml"][-1:] != '/':
                self.emld["@context"]["@vocab"] = my_dict["eml:eml"]["@xmlns:eml"] + '/' 
            else:
                self.emld["@context"]["@vocab"] = my_dict["eml:eml"]["@xmlns:eml"]
                
            # Assign a value to self.emld["@context"]["eml"]
            if my_dict["eml:eml"]["@xmlns:eml"][-1:] != '/':
                self.emld["@context"]["eml"] = my_dict["eml:eml"]["@xmlns:eml"] + '/' 
            else:
                self.emld["@context"]["eml"] = my_dict["eml:eml"]["@xmlns:eml"]
                
            # Assign a value to self.emld["@context"]["xsi"]
            if my_dict["eml:eml"]["@xmlns:xsi"][-1:] != '/':
                self.emld["@context"]["xsi"] = my_dict["eml:eml"]["@xmlns:xsi"] + '/' 
            else:
                self.emld["@context"]["xsi"] = my_dict["eml:eml"]["@xmlns:xsi"]
              
            self.emld["@context"]["xml"] = "http://www.w3.org/XML/1998/namespace" # Assign a value to self.emld["@context"]["xml"]
            '''
            This is hard-coded because this value does not exist in the original xml and I haven't been able to trace where emld::as_emld() is pulling this value from.
            emld::as_emld() defines namespaces by calling emld::eml_ns() which is defined at line 50 here: https://github.com/ropensci/emld/blob/master/R/eml_version.R
            1998 is not defined (i.e., hard-coded) in emld::eml_ns(), which tells me it's not a default value defined in the package library(emld)
            1998 is also not present in the original xml `r_original_xml` or `py_xml` for emld::eml_ns() to point to (i.e., `grepl("1998", as.character(r_original_xml)) == FALSE`)
            which tells me emld::as_emld() isn't pulling this value from the user-provided xml
            the remaining option is that emld::as_emld() is pointing to a remote for this value
            Since I haven't traced where this remote is located,
            I have no choice but to hard-code this value until I can figure out how library(emld) is finding a value for ["@context"]["xml"].
            '''
            self.emld["@context"]["stmml"] = my_dict["eml:eml"]["@xmlns:stmml"] # Assign a value to self.emld["@context"]["stmml"]
            self.emld["@context"]["id"] = "@id" # Assign a value to self.emld["@context"]["id"]
            self.emld["@context"]["@base"] = "eml://" # Assign a value to self.emld["@context"]["@base"]
            self.emld["dataset"] = my_dict["eml:eml"]["dataset"] # Assign a value to self.emld["dataset"]
            self.emld["additionalMetadata"] = my_dict["eml:eml"]["additionalMetadata"] # Assign a value to self.emld["additionalMetadata"]
            self.emld["packageId"] = my_dict["eml:eml"]["@packageId"] # Assign a value to self.emld["packageId"]
            self.emld["schemaLocation"] = my_dict["eml:eml"]["@xsi:schemaLocation"] # Assign a value to self.emld["schemaLocation"]
            self.emld["system"] = my_dict["eml:eml"]["@system"] # Assign a value to self.emld["schemaLocation"]
            self.emld["@type"] = "EML" # Assign a value to self.emld["@context"]["@base"]
            
            print("Emld instance created!") # print success message
        except:
            print("An error occurred and your Emld did not instantiate.")
        
    def set_cui(self, cui_code:str = ("PUBLIC", "NOCON", "DL_ONLY", "FEDCON", "FED_ONLY"), force:bool = False, NPS:bool = True):
        '''Setter function for controlled unclassified information (CUI)'''
        # @param cui_code a string consisting of one of 7 potential CUI codes (defaults to "PUBFUL").
            # FED_ONLY - Contains CUI. Only federal employees should have access (similar to "internal only" in DataStore)
            # FEDCON - Contains CUI. Only federal employees and federal contractors should have access (also very much like current "internal only" setting in DataStore)
            # DL_ONLY - Contains CUI. Should only be available to a names list of individuals (where and how to list those individuals TBD)
            # NOCON - Contains  CUI. Federal, state, local, or tribal employees may have access, but contractors cannot.
            # PUBLIC - Does NOT contain CUI.
        # @param force bool
            # Default False
            # True means the program will over-write any value in <metadata><CUI> if one exists or create that tag and add `cui_code` if !exists
            # False prints the value of <metadata><CUI> to console and asks the user to decide to over-write or not
        # @param NPS bool
            # Default True
            # True means
            # False means
        
        # saving in case I need to pivot to xml instead of dict
        # https://www.geeksforgeeks.org/turning-a-dictionary-into-xml-in-python/
        
        
        # verify CUI code entry; stop if does not equal one of six valid codes listed above:
        assert cui_code in ("PUBLIC", "NOCON", "DL_ONLY", "FEDCON", "FED_ONLY"), 'You must choose a `cui_code` from the pick-list: ("PUBLIC", "NOCON", "DL_ONLY", "FEDCON", "FED_ONLY")'
        assert force in (True, False), "Parameter `force` must be either True or False."
        assert NPS in (True, False), "Parameter `NPS` must be either True or False."
        
        # procedure
        try:
            if force == True:
                self.emld["additionalMetadata"]["metadata"]['@id'] = "CUI" # set the value of attribute "id" in <additionalMetadata id=fill_in_the_blank> with "CUI"
                self.emld["additionalMetadata"]["metadata"]["CUI"] = cui_code   # set the value of <metadata><CUI>
                print(f"Value of <CUI> set to '{cui_code}'\nParameter 'id' set to 'CUI'!")
        except:
            print("CUI did not update.")

        
    def set_title(self, data_package_title:str, force:bool = False, NPS:bool = True):
        # @param data_package_title str
            # The title the user wants to change their data package title to
            # e.g., data_package_title = "My new title"
        # @param force bool
            # Default False
            # True means the program will over-write any value in <metadata><CUI> if one exists or create that tag and add `cui_code` if !exists
            # False prints the value of <metadata><CUI> to console and asks the user to decide to over-write or not
        # @param NPS bool
            # Default True
            # True means
            # False means
            
        # validate user input
        assert data_package_title != "", "Parameter `data_package_title` cannot be blank"
        assert force in (True, False), "Parameter `force` must be either True or False."
        assert NPS in (True, False), "Parameter `NPS` must be either True or False."
        
        # procedure
        try:
            if force == True:
                self.emld["dataset"]["title"] = data_package_title # set the value of attribute "title"
                print(f"Value of dataset title set to '{data_package_title}'!")
            if force == False:
                if self.emld["dataset"]["title"] != None:
                    print(f'Your dataset already has a title: {self.emld["dataset"]["title"]}')
                    user_choice = input("Do you want to overwrite your original title?\n'y' then enter to overwrite or 'n' then enter to keep original title\n\n")
                    if user_choice != 'y':
                        pass
                    else:
                        self.emld["dataset"]["title"] = data_package_title
                        print(f"You overwrote your original data package title to '{data_package_title}'!")
                        
            if NPS == True:
                # need to figure out what's going on here line 50 https://github.com/nationalparkservice/EMLeditor/blob/main/R/editEMLfunctions.R
                # what are .set_npspublisher() and .set_version()?????
                # Set NPS publisher, if it doesn't already exist
                    # if (NPS == TRUE) {
                    #     eml_object <- .set_npspublisher(eml_object)
                    # }
                    # # add/update EMLeditor and version to metadata:
                    # eml_object <- .set_version(eml_object)
                pass
            else:
                pass
        except:
            print("Title did not update.")
        
    def write_eml(self, destination_filename:str, attr_type:bool = False):
        '''Write emld to .xml'''
        # @param destination_filename
            # the name and filepath, including the .xml file extension, where the Emld.emld should be saved
        # @param attr_type
            # default value is False
            # True adds an attribute to every xml tag that specifies the data type stored in that tag
            # e.g., If a tag holds string data (str), its tag might be this: <mytag type="str">
            # False omits the attribute tag like this: <mytag>
            
        # validate user input
        assert destination_filename != "", "File cannot be blank"
        assert destination_filename.lower().endswith(".xml"), "File must end with '.xml'"
        assert attr_type in (True, False), "Parameter `attr_type` must be either True or False."
        
        # procedure
        try:
            xmloutput = dicttoxml.dicttoxml(self.emld, attr_type = attr_type)
            xml_decode = xmloutput.decode()
            xmlfile = open(destination_filename, "w")
            xmlfile.write(xml_decode)
            xmlfile.close()
        except:
            print("Unable to write eml to xml.")
        
    def print_eml(self, attr_type:bool = False):
        '''Pretty-print xml to console'''
        # @param attr_type
            # default value is False
            # True adds an attribute to every xml tag that specifies the data type stored in that tag
            # e.g., If a tag holds string data (str), its tag might be this: <mytag type="str">
            
        # validate user input
        assert attr_type in (True, False), "Parameter `attr_type` must be either True or False."
        
        # procedure
        try:
            xmloutput = dicttoxml.dicttoxml(self.emld, attr_type = attr_type)
            print(parseString(xmloutput).toprettyxml())
            # eventually, update to:
            # print(xmltodict.unparse(myemld.emld["additionalMetadata"], pretty=True))
        except:
            print("error in printing eml")
    

